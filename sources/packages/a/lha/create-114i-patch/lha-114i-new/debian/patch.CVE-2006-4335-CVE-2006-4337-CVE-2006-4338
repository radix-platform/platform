diff -aur lha-1.14i.orig/src/huf.c lha-1.14i/src/huf.c
--- lha-1.14i.orig/src/huf.c	2000-10-05 19:35:49.000000000 +0200
+++ lha-1.14i/src/huf.c	2006-12-11 10:07:31.000000000 +0100
@@ -332,7 +332,7 @@
 	}
 	else {
 		i = 0;
-		while (i < n) {
+		while (i < MIN(n, NPT)) {
 			c = bitbuf >> (16 - 3);
 			if (c == 7) {
 				unsigned short  mask = 1 << (16 - 4);
@@ -345,7 +345,7 @@
 			pt_len[i++] = c;
 			if (i == i_special) {
 				c = getbits(2);
-				while (--c >= 0)
+				while (--c >= 0 && i < NPT)
 					pt_len[i++] = 0;
 			}
 		}
@@ -370,7 +370,7 @@
 			c_table[i] = c;
 	} else {
 		i = 0;
-		while (i < n) {
+		while (i < MIN(n,NC)) {
 			c = pt_table[bitbuf >> (16 - 8)];
 			if (c >= NT) {
 				unsigned short  mask = 1 << (16 - 9);
@@ -380,7 +380,7 @@
 					else
 						c = left[c];
 					mask >>= 1;
-				} while (c >= NT);
+				} while (c >= NT && (mask || c != left[c])); /* CVE-2006-4338 */
 			}
 			fillbuf(pt_len[c]);
 			if (c <= 2) {
@@ -427,7 +427,7 @@
 			else
 				j = left[j];
 			mask >>= 1;
-		} while (j >= NC);
+		} while (j >= NC && (mask || j != left[j])); /* CVE-2006-4338 */
 		fillbuf(c_len[j] - 12);
 	}
 	return j;
@@ -451,7 +451,7 @@
 			else
 				j = left[j];
 			mask >>= 1;
-		} while (j >= np);
+		} while (j >= np && (mask || j != left[j])); /* CVE-2006-4338 */
 		fillbuf(pt_len[j] - 8);
 	}
 	if (j != 0)
Only in lha-1.14i/src: huf.c~
diff -aur lha-1.14i.orig/src/lha_macro.h lha-1.14i/src/lha_macro.h
--- lha-1.14i.orig/src/lha_macro.h	2006-12-11 09:43:54.000000000 +0100
+++ lha-1.14i/src/lha_macro.h	2006-12-11 09:55:42.000000000 +0100
@@ -408,6 +408,8 @@
 #define MAXMATCH			256	/* formerly F (not more than UCHAR_MAX + 1) */
 #define THRESHOLD			3	/* choose optimal value */
 
+#define MIN(a,b) ((a) <= (b) ? (a) : (b))
+
 /* from huf.c */
 
 /* alphabet = {0, 1, 2, ..., NC - 1} */
Only in lha-1.14i/src: lha_macro.h~
diff -aur lha-1.14i.orig/src/maketbl.c lha-1.14i/src/maketbl.c
--- lha-1.14i.orig/src/maketbl.c	2000-10-04 16:57:38.000000000 +0200
+++ lha-1.14i/src/maketbl.c	2006-12-11 09:59:51.000000000 +0100
@@ -32,8 +32,15 @@
 	}
 
 	/* count */
-	for (i = 0; i < nchar; i++)
-		count[bitlen[i]]++;
+	for (i = 0; i < nchar; i++) {
+		if (bitlen[i] > 16) {
+		/* CVE-2006-4335 */
+		error("Bad table (case a)");
+		exit(1);
+	}
+	else
+		count[bitlen[i]]++;
+	}
 
 	/* calculate first code */
 	total = 0;
@@ -41,8 +48,11 @@
 		start[i] = total;
 		total += weight[i] * count[i];
 	}
-	if ((total & 0xffff) != 0)
-		error("make_table()", "Bad table (5)\n");
+
+	if ((total & 0xffff) != 0 || tablebits > 16) { /* 16 for weight below */
+		error("make_table(): Bad table (case b)");
+		exit(1);
+	}
 
 	/* shift data for make table. */
 	m = 16 - tablebits;
@@ -53,7 +63,7 @@
 
 	/* initialize */
 	j = start[tablebits + 1] >> m;
-	k = 1 << tablebits;
+	k = MIN(1 << tablebits, 4096);
 	if (j != 0)
 		for (i = j; i < k; i++)
 			table[i] = 0;
@@ -66,12 +76,19 @@
 		l = start[k] + weight[k];
 		if (k <= tablebits) {
 			/* code in table */
+		l = MIN(l, 4096);
 			for (i = start[k]; i < l; i++)
 				table[i] = j;
 		}
 		else {
 			/* code not in table */
-			p = &table[(i = start[k]) >> m];
+			i = start[k];
+			if ((i >> m) > 4096) {
+			/* CVE-2006-4337 */
+			error("Bad table (case c)");
+			exit(1);
+			}
+			p = &table[i >> m];
 			i <<= tablebits;
 			n = k - tablebits;
 			/* make tree (n length) */
Only in lha-1.14i/src: maketbl.c~
